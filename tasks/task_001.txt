# Task ID: 1
# Title: Setup Project Structure and Configuration Manager
# Status: pending
# Dependencies: None
# Priority: high
# Description: Create the initial project structure and implement the Configuration Manager component that handles user settings, primarily the path to the research folder.
# Details:
Create a Node.js/Python project with appropriate directory structure. Implement a Configuration Manager class that can read/write configuration settings from a file (e.g., JSON or YAML). The primary configuration setting will be the path to the research folder. Include validation to ensure the specified folder exists and is accessible. Provide a simple interface for updating this configuration.

# Test Strategy:
Write unit tests to verify the Configuration Manager can correctly read, validate, and write folder paths. Test edge cases like invalid paths, permission issues, and empty values.

# Subtasks:
## 1. Initialize Project and Create Directory Structure [done]
### Dependencies: None
### Description: Set up the initial project with appropriate directory structure and package management for either Node.js or Python, following modern project organization principles.
### Details:
1. Create the root project directory
2. Initialize version control with Git
3. For Python: Create a virtual environment, requirements.txt, and setup.py
   - Use `python -m venv venv` for environment creation
   - Include essential packages like pydantic for validation
4. For Node.js: Initialize npm with package.json
   - Run `npm init -y`
   - Add dependencies like dotenv and config
5. Create the following directory structure:
   ```
   project_root/
   ├── src/
   │   ├── config/
   │   │   └── __init__.py (or index.js)
   │   ├── utils/
   │   │   └── __init__.py (or index.js)
   │   └── __init__.py (or index.js)
   ├── tests/
   │   └── __init__.py (or index.js)
   ├── docs/
   ├── .gitignore
   └── README.md
   ```
6. Create a comprehensive .gitignore file using templates from gitignore.io
7. Document the project structure in README.md

<info added on 2025-05-08T22:09:32.068Z>
## Enhanced Project Initialization Details

### Python Project Setup

1. **Advanced Virtual Environment Configuration**:
   ```bash
   # Create and activate virtual environment
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate

   # Install development packages
   pip install pytest pytest-cov black isort mypy
   ```

2. **Comprehensive `setup.py` Configuration**:
   ```python
   from setuptools import setup, find_packages

   setup(
       name="research_context_mcp",
       version="0.1.0",
       description="Research Context Management Control Program",
       author="Your Name",
       author_email="your.email@example.com",
       packages=find_packages(where="src"),
       package_dir={"": "src"},
       python_requires=">=3.8",
       install_requires=[
           "pydantic>=2.0.0",
           "python-dotenv>=1.0.0",
       ],
       extras_require={
           "dev": [
               "pytest>=7.0.0",
               "pytest-cov>=4.0.0",
               "black>=23.0.0",
               "isort>=5.12.0",
               "mypy>=1.0.0",
           ]
       },
       classifiers=[
           "Development Status :: 3 - Alpha",
           "Intended Audience :: Developers",
           "Programming Language :: Python :: 3",
           "Programming Language :: Python :: 3.8",
           "Programming Language :: Python :: 3.9",
           "Programming Language :: Python :: 3.10",
       ],
   )
   ```

3. **Configuration Management Setup**:
   ```python
   # src/config/__init__.py
   from pathlib import Path
   from pydantic import BaseModel
   from typing import Optional, Dict, Any
   import os
   import json

   class AppConfig(BaseModel):
       app_name: str = "ResearchContextMCP"
       debug_mode: bool = False
       log_level: str = "INFO"
       data_dir: Optional[Path] = None

       @classmethod
       def from_env(cls) -> "AppConfig":
           """Load configuration from environment variables"""
           return cls(
               app_name=os.getenv("APP_NAME", "ResearchContextMCP"),
               debug_mode=os.getenv("DEBUG_MODE", "False").lower() == "true",
               log_level=os.getenv("LOG_LEVEL", "INFO"),
               data_dir=Path(os.getenv("DATA_DIR", "./data")) if os.getenv("DATA_DIR") else None
           )

   # Default config instance
   config = AppConfig.from_env()
   ```

4. **Additional Project Structure Elements**:
   ```
   project_root/
   ├── .github/                    # GitHub workflows and templates
   │   └── workflows/
   │       └── python-tests.yml    # CI workflow for running tests
   ├── data/                       # Data directory for application
   │   └── .gitkeep                # Ensures directory is tracked by git
   ├── scripts/                    # Utility scripts for development/deployment
   │   └── setup_dev.sh            # Script to set up development environment
   ├── src/
   │   ├── models/                 # Data models directory
   │   │   └── __init__.py
   │   ├── services/               # Business logic services
   │   │   └── __init__.py
   │   └── main.py                 # Application entry point
   ├── .pre-commit-config.yaml     # Pre-commit hooks configuration
   ├── pyproject.toml              # Modern Python project configuration
   └── CHANGELOG.md                # Project changelog
   ```

5. **Pre-commit Configuration**:
   ```yaml
   # .pre-commit-config.yaml
   repos:
   - repo: https://github.com/pre-commit/pre-commit-hooks
     rev: v4.4.0
     hooks:
     - id: trailing-whitespace
     - id: end-of-file-fixer
     - id: check-yaml
     - id: check-added-large-files

   - repo: https://github.com/psf/black
     rev: 23.3.0
     hooks:
     - id: black

   - repo: https://github.com/pycqa/isort
     rev: 5.12.0
     hooks:
     - id: isort
   ```
</info added on 2025-05-08T22:09:32.068Z>

## 2. Design and Implement Configuration Schema [pending]
### Dependencies: 1.1
### Description: Create a configuration schema that defines the structure and validation rules for application settings, with a focus on the research folder path.
### Details:
1. Create a configuration schema file in src/config/
   - For Python: Use pydantic models or dataclasses
   - For Node.js: Use JSON Schema or TypeScript interfaces
2. Define the schema with the following properties:
   - research_folder_path (string, required)
   - app_name (string, optional)
   - debug_mode (boolean, optional, default: false)
3. Implement validation rules:
   - research_folder_path must be a valid directory path
   - Include type checking for all properties
4. Example Python implementation using pydantic:
   ```python
   # src/config/schema.py
   from pydantic import BaseModel, validator
   import os

   class ConfigSchema(BaseModel):
       research_folder_path: str
       app_name: str = "Research Manager"
       debug_mode: bool = False

       @validator('research_folder_path')
       def validate_research_path(cls, v):
           if not os.path.isdir(v):
               raise ValueError(f"Directory does not exist: {v}")
           if not os.access(v, os.R_OK | os.W_OK):
               raise ValueError(f"Directory is not accessible: {v}")
           return v
   ```
5. Write unit tests for the schema validation

## 3. Implement Configuration Manager Class [pending]
### Dependencies: 1.2
### Description: Create a Configuration Manager class that implements the Singleton pattern to ensure a single source of truth for application settings.
### Details:
1. Create the Configuration Manager class in src/config/
2. Implement the Singleton pattern to ensure only one instance exists
3. Add methods for loading, accessing, and modifying configuration
4. Include environment variable support for overriding file-based settings
5. Example Python implementation:
   ```python
   # src/config/manager.py
   import os
   import json
   from .schema import ConfigSchema

   class ConfigurationManager:
       _instance = None

       def __new__(cls, config_path=None):
           if cls._instance is None:
               cls._instance = super(ConfigurationManager, cls).__new__(cls)
               cls._instance._config = None
               cls._instance._config_path = config_path or os.path.join(
                   os.path.expanduser("~"), ".research_app_config.json"
               )
               cls._instance._load_config()
           return cls._instance

       def _load_config(self):
           # Try to load from file
           try:
               if os.path.exists(self._config_path):
                   with open(self._config_path, 'r') as f:
                       config_data = json.load(f)
               else:
                   config_data = {}
           except Exception as e:
               print(f"Error loading config: {e}")
               config_data = {}

           # Override with environment variables if present
           if os.environ.get("RESEARCH_FOLDER_PATH"):
               config_data["research_folder_path"] = os.environ.get("RESEARCH_FOLDER_PATH")

           # Use default if still missing
           if "research_folder_path" not in config_data:
               config_data["research_folder_path"] = os.path.join(
                   os.path.expanduser("~"), "research"
               )

           # Validate through schema
           try:
               self._config = ConfigSchema(**config_data)
           except Exception as e:
               raise ValueError(f"Invalid configuration: {e}")

       def get_research_folder(self):
           return self._config.research_folder_path

       def get_config(self):
           return self._config
   ```
6. Write unit tests with mocking for file operations

## 4. Implement Configuration Persistence [pending]
### Dependencies: 1.3
### Description: Create functionality to save and load configuration settings to/from a file, ensuring settings persist between application runs.
### Details:
1. Extend the Configuration Manager with save functionality
2. Implement error handling for file operations
3. Add atomic file writing to prevent corruption
4. Include backup of previous configuration
5. Example Python implementation:
   ```python
   # Add to src/config/manager.py
   import tempfile
   import shutil

   def save_config(self):
       """Save configuration to file atomically"""
       config_dict = self._config.dict()

       # Create backup if file exists
       if os.path.exists(self._config_path):
           backup_path = f"{self._config_path}.bak"
           shutil.copy2(self._config_path, backup_path)

       # Write to temporary file first
       fd, temp_path = tempfile.mkstemp()
       try:
           with os.fdopen(fd, 'w') as temp_file:
               json.dump(config_dict, temp_file, indent=2)

           # Atomic replacement
           shutil.move(temp_path, self._config_path)
           return True
       except Exception as e:
           print(f"Error saving configuration: {e}")
           if os.path.exists(temp_path):
               os.unlink(temp_path)
           return False

   def set_research_folder(self, path):
       """Update research folder path and save configuration"""
       # Validate path exists and is accessible
       if not os.path.isdir(path):
           raise ValueError(f"Directory does not exist: {path}")
       if not os.access(path, os.R_OK | os.W_OK):
           raise ValueError(f"Directory is not accessible: {path}")

       # Update config and save
       self._config.research_folder_path = path
       return self.save_config()
   ```
6. Test file operations with temporary directories
7. Implement recovery from backup if save fails

## 5. Create Configuration Interface and CLI [pending]
### Dependencies: 1.4
### Description: Develop a simple interface for viewing and updating configuration settings, including both programmatic API and command-line interface.
### Details:
1. Create a high-level API for configuration access
2. Implement a CLI for configuration management
3. Add input validation and user-friendly error messages
4. Include help text and examples
5. Example Python implementation:
   ```python
   # src/config/interface.py
   from .manager import ConfigurationManager

   def get_config():
       """Get the current configuration"""
       return ConfigurationManager().get_config()

   def set_research_folder(path):
       """Set the research folder path"""
       return ConfigurationManager().set_research_folder(path)

   # src/cli.py
   import argparse
   import sys
   from config.interface import get_config, set_research_folder

   def main():
       parser = argparse.ArgumentParser(description="Research App Configuration")
       subparsers = parser.add_subparsers(dest="command", help="Command to run")

       # Get config command
       get_parser = subparsers.add_parser("get", help="Get configuration")

       # Set research folder command
       set_parser = subparsers.add_parser("set-folder", help="Set research folder path")
       set_parser.add_argument("path", help="Path to research folder")

       args = parser.parse_args()

       try:
           if args.command == "get":
               config = get_config()
               print(f"Research folder: {config.research_folder_path}")
               print(f"App name: {config.app_name}")
               print(f"Debug mode: {config.debug_mode}")
           elif args.command == "set-folder":
               if set_research_folder(args.path):
                   print(f"Research folder set to: {args.path}")
               else:
                   print("Failed to set research folder")
                   sys.exit(1)
           else:
               parser.print_help()
       except Exception as e:
           print(f"Error: {e}")
           sys.exit(1)

   if __name__ == "__main__":
       main()
   ```
6. Add entry point in setup.py for CLI access
7. Create integration tests for the CLI
8. Document the API and CLI usage in README.md
